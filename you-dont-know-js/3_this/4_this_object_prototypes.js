//RULES


//1.
//Привязка по умолчанию. НЕ РАБОТАЕТ В НОДЕ. ТОЛЬКО В JS.
// function foo() {
//     console.log( this.a );
// }
// var a = 2;
// foo(); // 2


//2. Неявная привязка
//точка вызова использует контекст obj, чтобы ссылаться на функцию, поэтому можно сказать, что объект obj "владеет"
// или "содержит" ссылку на функцию в момент вызова функции.
// function foo() {
//     console.log( this.a );
// }
//
// var obj = {
//     a: 2,
//     foo: foo
// };
//
// obj.foo(); // 2


//Неявно потерянный. НЕ РАБОТАЕТ В НОДЕ. ТОЛЬКО В JS.
// function foo() {
//     console.log( this.a ); //Cannot read properties of undefined (reading 'a')
// }
//
// var obj = {
//     a: 2,
//     foo: foo
// };
//
// var bar = obj.foo; // ссылка/алиас на функцию!
//
// var a = "ой, глобальная"; // `a` также и свойство глобального объекта
//
// bar(); // "ой, глобальная"


//3. Явная привязка

//Вызов foo с явной привязкой посредством foo.call(..) позволяет нам указать, что this будет obj.
// function foo() {
//     console.log( this.a );
// }
//
// var obj = {
//     a: 2
// };
//
// foo.call( obj ); // 2


//Самый типичный способ обернуть функцию с жесткой привязкой — создать сквозную обертку, передающую все параметры и
// возвращающую полученное значение:
// function foo(something) {
//     console.log('this.a', this.a, 'something', something);
//     return this.a + something;
// }
//
// var obj = {
//     a: 2
// };
//
// var bar = function () {
//     return foo.apply(obj, arguments);
// };
//
// var b = bar(3); // 2 3
// console.log('b', b); // 5

//Еще один способ выразить этот шаблон — создать переиспользуемую вспомогательную функцию:
// function foo(something) {
//     console.log('this.a', this.a, 'something', something);
//     return this.a + something;
// }
//
// // простая вспомогательная функция `bind`
// function bind(fn, obj) {
//     return function () {
//         return fn.apply(obj, arguments);
//     };
// }
//
// var obj = {
//     a: 2
// };
//
// var bar = bind(foo, obj);
//
// var b = bar(3); // 2 3
// console.log('b', b); // 5


//Поскольку жесткая привязка — очень распространеный шаблон, он есть как встроенный инструмент в ES5:
// Function.prototype.bind, а используется вот так:
//bind(..) возвращает новую функцию, в которой жестко задан вызов оригинальной функции с именно тем контекстом this,
// который вы указываете.
// function foo(something) {
//     console.log(this.a, something);
//     return this.a + something;
// }
//
// var obj = {
//     a: 2
// };
//
// var bar = foo.bind(obj);
//
// var b = bar(3); // 2 3


//4. Привязка new

//1. Создается новенький объект (т.е. конструируется) прямо из воздуха
//2. Только что сконструированный объект связывается с [[Прототипом]]
//3. Только что сконструированный объект устанавливается как привязка this для этого вызова функции
//4. За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, вызов функции с new
// автоматически вернет только что сконструированный объект.

//нет никакой связи с классо-ориентированной функциональностью у той, что предполагает использование new в JS.

// function foo(a) {
//     this.a = a;
// }
//
// var bar = new foo( 2 );
// console.log( bar.a ); // 2
//Вызывая foo(..) с new впереди нее, мы конструируем новый объект и устанавливаем этот новый объект как this для вызова
// foo(..). Таким образом new — единственный путь, которым this при вызове функции может быть привязан.
// Мы называем это привязкой new.


//5. Всё по порядку

//явная привязка имеет приоритет над неявной привязкой

// function foo() {
//     console.log( this.a );
// }
//
// var obj1 = {
//     a: 2,
//     foo: foo
// };
//
// var obj2 = {
//     a: 3,
//     foo: foo
// };
//
// obj1.foo(); // 2
// obj2.foo(); // 3
//
// obj1.foo.call( obj2 ); // 3
// obj2.foo.call( obj1 ); // 2


//привязка new более приоритетна, чем неявная привязка
// function foo(something) {
//     this.a = something;
// }
//
// var obj1 = {
//     foo: foo
// };
//
// var obj2 = {};
//
// obj1.foo( 2 );
// console.log( obj1.a ); // 2
//
// obj1.foo.call( obj2, 3 );
// console.log( obj2.a ); // 3
//
// var bar = new obj1.foo( 4 );
// console.log( obj1.a ); // 2
// console.log( bar.a ); // 4

//bar жестко связан с obj1, но new bar(3) не меняет obj1.a на значение 3 что было бы ожидаемо нами.
// Вместо этого жестко связанный (с obj1) вызов bar(..) может быть перекрыт с new.
// Поскольку был применен new, обратно мы получили новый созданный объект, который мы назвали baz, и в результате видно,
// что в baz.a значение 3.
// function foo(something) {
//     this.a = something;
// }
//
// var obj1 = {};
//
// var bar = foo.bind( obj1 );
// bar( 2 );
// console.log( obj1.a ); // 2
//
// var baz = new bar( 3 );
// console.log( obj1.a ); // 2
// console.log( baz.a ); // 3


//6. Стрелочные функции обозначаются не ключевым словом function, а операцией =>, так называемой "жирной стрелкой".
// Вместо использования четырех стандартных this-правил, стрелочные функции заимствуют привязку this из окружающей
// (функции или глобальной) области видимости.

// function foo() {
//     // возвращаем стрелочную функцию
//     return (a) => {
//         // Здесь `this` лексически заимствован из `foo()`
//         console.log( this.a );
//     };
// }
//
// var obj1 = {
//     a: 2
// };
//
// var obj2 = {
//     a: 3
// };
//
// var bar = foo.call( obj1 );
// bar.call( obj2 ); // 2, а не 3!


//Определяем this
// Теперь можно кратко сформулировать правила для определения this по точке вызова функции, в порядке их приоритета.
// Зададим вопросы в том же порядке и остановимся как только будет применено первое же правило.
// 1. Функция вызвана с new (привязка new)? Раз так, то this — новый сконструированный объект.
// var bar = new foo()
// 2. Функция вызвана с call или apply (явная привязка), даже скрыто внутри жесткой привязки в bind? Раз так, this — явно указанный объект.
// var bar = foo.call( obj2 )
// 3. Функция вызвана с контекстом (неявная привязка), иначе называемым как владеющий или содержащий объект? Раз так, this является тем самым объектом контекста.
// var bar = obj1.foo()
// 4. В противном случае, будет this по умолчанию (привязка по умолчанию). В режиме strict mode, это будет undefined, иначе будет объект global.
// var bar = foo()