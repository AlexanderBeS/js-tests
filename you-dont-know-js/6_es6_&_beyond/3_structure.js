//итераторы, генераторы, модули и классы.

//Итераторы
//Итератором (iterator) называется структурированный шаблон, предназначенный для последовательного извлечения информации из источника.
let arr1 = [1, 2, 3];
let it1 = arr1[Symbol.iterator]();
console.log(it1.next()); // { value: 1, done: false }
console.log(it1.next()); // { value: 2, done: false }
console.log(it1.next()); // { value: 3, done: false }
console.log(it1.next()); // { value: undefined, done: true }

//Генераторы
//Такая функция может остановиться во время выполнения, а затем
// продолжить работу с прерванного места.
//function *foo(..) { .. }.
//Внутри генераторов используется ключевое слово, сигнализирующее о прерывании работы: yield.

function* foo1() {
    while (true) {
        yield Math.random();
    }
}

let it2 = foo1();
console.log(it2.next());
console.log(it2.next());

function* foo2() {
    try {
        yield* [1, 2, 3];
    } finally {
        console.log("cleanup!");
    }
}

let it3 = foo2();
console.log(it3.next());
console.log(it3.next());
console.log(it3.return(42)); //Раннее завершение


//Применение генераторов


//Модули
//Node.js has two module systems: CommonJS modules and ECMAScript modules.

//CommonJs
//const Square = require('./square.js');
//module.exports

//ES6
//export function foo() {}
//export { foo }
//export { foo as bar };
//На самом деле при экспорте какого-либо элемента вы передаете
// привязку (своего рода указатель).

//Если вы поменяете внутри модуля значение переменной, привязку
// к которой уже экспортировали, то, даже если ее импорт уже завер-
// шился (см. следующий раздел), импортированная привязка даст
// текущее (обновленное) значение.

//1 export default foo;
//В первом случае вы экспортируете привязку в значение функцио-
// нального выражения, а не в идентификатор foo. Другими словами,
// export default .. преобразовывает выражение. Если позднее при-
// своить функцию foo другому значению внутри модуля, процедура
// импорта все равно будет показывать изначально экспортированную
// функцию.


//2 export { foo as default };
//Здесь привязка экспорта по умолчанию на самом деле выполняет-
// ся к идентификатору foo, а не к его значению, то есть вы получаете
// ранее описанное поведение (в частности, если позднее вы поменя-
// ете значение foo, обновится и значение на стороне импорта).

//import { foo, bar, baz } from "foo";
//Строка "foo" называется спецификатором модуля (module specifier).
//import { foo as theFooFunc } from "foo";

//Допустим, модуль "foo" экспортируется следующим образом:
// export function bar() { .. }
// export var x = 42;
// export function baz() { .. }
// Вы можете импортировать API целиком в единую привязку к про-
// странству имен модуля:
// import * as foo from "foo";
// foo.bar();
// foo.x; // 42
// foo.baz();


//Циклическая зависимость модулей
//Начнем с моду-
// ля "A":
// import bar from "B";
// export default function foo(x) {
// if (x > 10) return bar( x - 1 );
// return x * 2;
// }
// А вот модуль "B":
// import foo from "A";
// export default function bar(y) {
// if (y > 5) return foo( y / 2 );
// return

//Коротко говоря, циклические зависимости импорта проверяются
// и разрешаются следующим образом.
//  Если первым загружается модуль "А", сначала файл сканиру-
// ется и анализируется на предмет результатов экспорта, чтобы
// получить возможность зарегистрировать все доступные для
// импорта привязки. Затем обрабатывается выражение import
// .. from "B", сообщающее, что пришло время извлечь модуль "B".
//  После загрузки модуля "B" движок производит такой же
// анализ его привязок экспорта, как и в случае "А". Когда дело
// доходит до выражения import .. from "A", API модуля "А" уже
// известен, поэтому остается удостовериться в корректности
// импорта. Когда же становится известен API модуля "B", по-
// является возможность проверить также

//Семантика статической загрузки оператора import означает, что
// зависящие друг от друга модули "foo" и "bar" в результате импор-
// та будут гарантированно загружены, проанализированы и скомпи-
// лированы до запуска любого из них. То есть циклическая зависи-
// мость разрешается статически, и все работает ожидаемым образом.


//Классы
// class Foo {
//     constructor(a, b) {
//         this.x = a;
//         this.y = b;
//     }
//
//     gimmeXY() {
//         return this.x * this.y;
//     }
// }




//---------------------------------
//Ключевые слова extends и super
// В конструкторе это ключевое слово автоматически
// ссылается на «родительский конструктор»
//Внутри метода super ссылается на
// «родительский объект», обеспечивая вам доступ к свойству/методу


class ParentA {
    constructor() {
        this.id = "a";
    }

    foo() {
        console.log("ParentA:", this.id);
    }
}

class ParentB {
    constructor() {
        this.id = "b";
    }

    foo() {
        console.log("ParentB:", this.id);
    }
}

class ChildA extends ParentA {
    foo() {
        super.foo();
        console.log("ChildA:", this.id);
    }
}

class ChildB extends ParentB {
    foo() {
        super.foo();
        console.log("ChildB:", this.id);
    }
}

let a = new ChildA();
a.foo(); // ParentA: a
// ChildA: a
let b = new ChildB(); // ParentB: b
b.foo(); // ChildB: b

b.foo.call( a ); // ParentB: a
// ChildB: a

//Конструктор подкласса

//используемый по умолчанию конструктор подкласса
// автоматически вызывает родительский конструктор и передает
// любые аргументы туда.

//constructor(...args) {
// super(...args);
// }

// В ES6 на конструкторы подклассов накладывается еще одно стран-
// ное ограничение. Доступ к ключевому слову this в таком конструк-
// торе появляется только после вызова метода super(..).




//---------------------------------
//Расширение встроенных объектов
//class MyCoolArray extends Array {
// first() { return this[0]; }
// last() { return this[this.length - 1]; }
// }

class Oops extends Error {
    constructor(reason) {
        super();
        this.oops = reason;
    }
}
// позднее:
let ouch = new Oops( "I messed up!" );
// throw ouch;




//---------------------------------
//Свойство new.target
//Свойство new.target представляет собой новое «магическое» значе-
// ние, доступное во всех функциях, хотя в обычных функциях оно
// всегда равняется undefined. В любом конструкторе new.target всегда
// будет указывать на конструктор, непосредственно вызвавший опе-
// ратор new, даже если тот располагается в параллельном классе и был
// делегирован через вызов super(..) из дочернего конструктора

console.log('-----------------------');
class Foo {
    constructor() {
        console.log( "Foo: ", new.target.name );
    }
}
class Bar extends Foo {
    constructor() {
        super();
        console.log( "Bar: ", new.target.name );
    }

    baz() {
        //console.log( "baz: ", new.target );
    }
}
let a1 = new Foo();
// Foo: Foo
let b1 = new Bar();
// Foo: Bar <-- учитывает сторону, вызвавшую 'new'
// Bar: Bar
b1.baz();
// baz: undefined



//---------------------------------
//Ключевое слово static

//Тем не менее это бывает весьма полезно в случае, когда мы объ-
// являем статические методы (не только свойства) для класса, так
// как они добавляются непосредственно в его объект-функцию, а не
// в объект-прототип этой функции.

class Foo1 {
    static cool() { console.log( "cool" ); }
    wow() { console.log( "wow" ); }
}
class Bar1 extends Foo1 {
    static awesome() {
        super.cool();
        console.log( "awesome" );
    }
    neat() {
        super.wow();
        console.log( "neat" );
    }
}
Foo1.cool(); // "cool"
Bar1.cool(); // "cool"
Bar1.awesome(); // "cool"
                // "awesome"

let b2 = new Bar1();
b2.neat(); // "wow"
            // "neat"
b2.awesome; // undefined
b2.cool; // undefined


//---------------------------------
//Метод чтения конструктора
// в свойстве Symbol.species
//Эта возможность позволяет дочернему классу передать в родительский инфор-
// мацию о том, каким конструктором следует пользоваться — когда
// вы не собираетесь задействовать конструктор самого дочернего
// класса, — если какой-либо метод родительского класса должен породить новый экземпляр.

//Например, многие методы объекта Array создают и возвращают
// новые экземпляры Array. Если, определяя класс, производный от
// Array, вы хотите, чтобы эти методы продолжили создавать реальные
// экземпляры объекта Array вместо экземпляров производного клас-
// са, нужно сделать так:
// class MyCoolArray extends Array {
// // принудительно превращаем 'species' в родительский
// конструктор
// static get [Symbol.species]() { return Array; }
// }
// var a = new MyCoolArray( 1, 2, 3 ),
// b = a.map( function(v){ return v * 2; } );
// b instanceof MyCoolArray; // false
// b instanceof Array; // true








