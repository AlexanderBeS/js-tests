//Массивы
let a = [1, "2", [3]];
console.log('a.length - ', a.length) //3

//Предупреждение: Используя delete для значения array будет удалена ячейка array с этим значением, но даже если вы
// удалите последний элемент таким способом, это НЕ обновит свойство length

delete a[2];
console.log('a.length after deleting - ', a, a.length) //[ 1, '2', <1 empty item> ] 3


//------------------------------
let b = [];
b["13"] = 42;
console.log('b.length - ', b.length); // 14
//-----------------------------
//В ES6, Number.EPSILON определено заранее этим пороговым значением, так что если вы хотите его использовать, нужно
// применить полифилл для определения порогового значения для стандартов до-ES6:
if (!Number.EPSILON) {
    Number.EPSILON = Math.pow(2, -52);
}

//Мы можем использовать это значение Number.EPSILON для проверки двух чисел number на "равенство" (с учетом допуска ошибки округления):

function numbersCloseEnoughToEqual(n1, n2) {
    return Math.abs(n1 - n2) < Number.EPSILON;
}

let a1 = 0.1 + 0.2;
let b1 = 0.3;

console.log('Number.EPSILON - ', Number.EPSILON)
console.log(numbersCloseEnoughToEqual(a1, b1));					// true
console.log(numbersCloseEnoughToEqual(0.0000001, 0.0000002));	//false


//Максимальное целое число, которое может быть "безопасно" представлено (это означает гарантию того, что запрашиваемое
// значение будет представлено совершенно определенно) это 2^53 - 1, что составляет 9007199254740991
//Это значение автоматически предопределено в ES6, как Number.MAX_SAFE_INTEGER. Ожидаемо, минимальное значение,
// -9007199254740991, соответственно предопределено в ES6 как Number.MIN_SAFE_INTEGER.

//Проверяем является ли число целым
console.log(Number.isInteger(42));		// true
console.log(Number.isInteger(42.000));	// true
console.log(Number.isInteger(42.3));	// false

//================
//Оператор void
//Выражение void ___ "аннулирует" любое значение, так что результатом выражения всегда будет являться значение undefined.
// Это выражение не изменяет действующее значение; оно просто дает нам уверенность в том, что мы не получим назад
// другого значения после применения оператора.
let d = 42;
console.log(void d, d); // undefined 42

//===================
//НЕ Число, Число
// правильнее думать о NaN как о "неправильном числе", "ошибочном числе", или даже "плохом числе", чем думать о нем как о "НЕ числе".
let stringB = 'foo';
let numberA = 2 / stringB;		// NaN
console.log(typeof numberA === "number");	// true
console.log(numberA == NaN);	// false
console.log(numberA === NaN);	// false
//NaN !== NaN
console.log(isNaN(numberA)); // true
console.log(isNaN(stringB)); // true -- упс! Этот баг был в JS с самого начала

console.log(Number.isNaN(numberA)); // true
console.log(Number.isNaN(stringB)); // false -- фуух!


//=======================
//Бесконечности
console.log(1 / 0);	// Infinity
console.log(-1 / 0);	// -Infinity


//======================
//Нули
console.log(0 / -3); // -0
console.log(0 * -3); // -0

function isNegZero(n) {
    n = Number(n);
    return (n === 0) && (1 / n === -Infinity);
}

console.log(isNegZero(-0));		// true
console.log(isNegZero(0 / -3));	// true
console.log(isNegZero(0));			// false
//Есть определенные случаи где разработчики используют величину значения для определения одних данных (например скорость перемещения анимации в кадре) а знак этого числа number для представления других данных (например направление перемещения).
// В этих случаях, как в примере выше, если переменная достигнет нуля и потеряет знак, тогда, вы потеряете информацию о том, откуда она пришла, до того как достигла нулевого значения. Сохранение знака нуля предупреждает потерю этой информации.

//===========================
//Специальное равенство
let newA = 2 / "foo";
let newB = -3 * 0;

console.log(Object.is(newA, NaN));	// true
console.log(Object.is(newB, -0));		// true
console.log(Object.is(newB, 0));		// false

//===========================
//Значения и ссылки
//В JavaScript указатели не существуют, а ссылки работают несколько иначе. Одна переменная JS не может хранить ссылку на другую переменную -- это попросту невозможно.
// Ссылка в JS указывает на (общее) значение, так что, если вы создаете 10 разных ссылок, они всегда будут указывать на одно общее значение; они никогда не ссылаются/не указывают друг на друга.
// Тип значения управляет только тем, как будет выполняться присваивание -- копированием значения или копированние ссылки.

//Простые значения (то есть скалярные примитивы) всегда присваиваются/передаются копированием значения: это null, undefined, string, number, boolean и symbol из ES6.
// Составные значения -- объекты (включая массивы и все объектные обертки -- см. главу 3) и функции -- при присваивании или передаче всегда создают копию ссылки.

// var a = 2;
// var b = a; // `b` всегда содержит копию значения из `a`
// b++;
// a; // 2
// b; // 3
//
// var c = [1,2,3];
// var d = c; // `d` - ссылка на общее значение `[1,2,3]`
// d.push( 4 );
// c; // [1,2,3,4]
// d; // [1,2,3,4]




